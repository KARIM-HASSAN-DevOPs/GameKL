* Board representation

** Todo
- [ ] start placement
- [ ] getting resources
- [ ] available placements
- [ ] available trades
- [ ] legality checking

** Layout
                 *0*  0  *1*

                  1  (0)  2 

         *2*  3  *3*  4  *4*  5  *5*

          6  (1)  7  (2)  8  (3)  9 

 *6* 10  *7* 11  *8* 12  *9* 13 *10* 14 *11*

 15  (4) 16  (5) 17  (6) 18  (7) 19  (8) 20 

*12* 21 *13* 22 *14* 23 *15* 24 *16* 25 *17*

         26  (9) 27 (10) 28 (11) 29 

        *18* 30 *19* 31 *20* 32 *21*

                 33 (12) 34 

                *22* 35 *23*

** Elements of board representation
- nodes :: uint32 bitboard for each color
- branches :: uint64 bitboard for each color
- colors ::
- capacities :: 

** Transformations
In the below, sets will ultimately be represented as bitboards.

*** edge -> intersections
examples:
- edge_intersections[7]  = {3, 8}
- edge_intersections[12] = {8, 9}

*** edge -> adjacent edges
examples:
- edge_edges[7] = {1, 3, 4, 11, 12, 17}

** Bitboard operations
*** Available intersections for node placement
#+BEGIN_SRC
# Get intersections adjacent to color's branches
intersections = 0
for i in bitscan(branches[color])
  intersections |= edge_intersections[i]

# Limit it to open intersections
intersections &= ~(nodes[color] | node[!color])
#+END_SRC

*** Available edges for branch placement
#+BEGIN_SRC
# Get edges adjacent to color's branches
edges = 0
for i in bitscan(branches[color])
  edges |= edge_edges[i]

# Limit it to open edges
intersections &= ~(edges[color] | edges[!color])
#+END_SRC

*** Nodes
